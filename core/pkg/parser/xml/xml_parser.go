package xml

import (
	"encoding/xml"
	"paste-forge/pkg/parser"
	"paste-forge/pkg/schema"
	"strings"
)

type XMLParser struct{}

func NewXMLParser() parser.Parser {
	return &XMLParser{}
}

func (p *XMLParser) Name() string {
	return "xml"
}

func (p *XMLParser) CanParse(content string) bool {
	content = strings.TrimSpace(content)
	return strings.HasPrefix(content, "<")
}

func (p *XMLParser) Parse(content string) (*schema.Struct, error) {
	reader := strings.NewReader(content)
	decoder := xml.NewDecoder(reader)

	result := &schema.Struct{
		Name:   "AutoGenerated",
		Fields: []schema.Field{},
	}

	// Simple flat parse for demo. 
	// In reality, XML structure inference is complex (attributes vs elements, arrays).
	// We will attempt to decode into a generic map structure.
	// Since Go's encoding/xml doesn't support unmarshal into map[string]interface{} natively well,
	// we'll do a basic token traversal to find top-level elements of the root.

	// A better approach for XML to Schema inference usually involves reading the whole tree.
	// For this prototype, we'll try to guess based on immediate children of root.

	var inRoot bool
	rootName := ""
	
	for {
		t, _ := decoder.Token()
		if t == nil {
			break
		}
		switch se := t.(type) {
		case xml.StartElement:
			if !inRoot {
				inRoot = true
				rootName = se.Name.Local
				result.Name = toPascalCase(rootName)
				continue
			}
			
			// This is a child of root
			fieldName := se.Name.Local
			
			// Read content
			val, _ := decoder.Token()
			var kind schema.Kind = schema.KindString
			
			if v, ok := val.(xml.CharData); ok {
				sVal := string(v)
				// Heuristic type guessing
				if isInt(sVal) {
					kind = schema.KindInt
				} else if isBool(sVal) {
					kind = schema.KindBool
				}
			}

			// Add field
			result.Fields = append(result.Fields, schema.Field{
				Name:         toPascalCase(fieldName),
				OriginalName: fieldName,
				Kind:         kind,
			})

			// Skip to end of this element
			decoder.Skip() 
		}
	}

	return result, nil
}

func toPascalCase(s string) string {
	parts := strings.Split(s, "_")
	for i, p := range parts {
		if len(p) > 0 {
			parts[i] = strings.ToUpper(p[:1]) + p[1:]
		}
	}
	return strings.Join(parts, "")
}

func isInt(s string) bool {
	// simplified check
	return false 
}

func isBool(s string) bool {
	s = strings.ToLower(s)
	return s == "true" || s == "false"
}
