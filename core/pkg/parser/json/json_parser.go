package json

import (
	"encoding/json"
	"math"
	"strings"

	"paste-go/pkg/parser"
	"paste-go/pkg/schema"
)

type JSONParser struct{}

func NewJSONParser() parser.Parser {
	return &JSONParser{}
}

func (p *JSONParser) Name() string {
	return "json"
}

func (p *JSONParser) CanParse(content string) bool {
	content = strings.TrimSpace(content)
	if !strings.HasPrefix(content, "{") && !strings.HasPrefix(content, "[") {
		return false
	}
	var js json.RawMessage
	return json.Unmarshal([]byte(content), &js) == nil
}

func (p *JSONParser) Parse(content string) (*schema.Struct, error) {
	var data interface{}
	err := json.Unmarshal([]byte(content), &data)
	if err != nil {
		return nil, err
	}

	// Handle Array root: infer from first element if possible
	if arr, ok := data.([]interface{}); ok {
		if len(arr) > 0 {
			data = arr[0]
		} else {
			data = map[string]interface{}{}
		}
	}

	if m, ok := data.(map[string]interface{}); ok {
		return buildStruct("AutoGenerated", m), nil
	}

	return &schema.Struct{Name: "AutoGenerated", Fields: []schema.Field{}}, nil
}

func buildStruct(name string, m map[string]interface{}) *schema.Struct {
	result := &schema.Struct{
		Name:   name,
		Fields: []schema.Field{},
	}

	for k, v := range m {
		field := inferField(k, v)
		result.Fields = append(result.Fields, field)
	}

	return result
}

func inferField(key string, value interface{}) schema.Field {
	field := schema.Field{
		Name:         toPascalCase(key),
		OriginalName: key,
		Kind:         schema.KindAny,
	}

	switch v := value.(type) {
	case string:
		field.Kind = schema.KindString
	case float64:
		if math.Mod(v, 1) == 0 {
			field.Kind = schema.KindInt
		} else {
			field.Kind = schema.KindFloat
		}
	case bool:
		field.Kind = schema.KindBool
	case map[string]interface{}:
		field.Kind = schema.KindObject
		field.Nested = buildStruct(field.Name, v)
	case []interface{}:
		field.Kind = schema.KindArray
		if nested := inferArrayNested(field.Name, v); nested != nil {
			field.Nested = nested
		}
	default:
		field.Kind = schema.KindAny
	}

	return field
}

func inferArrayNested(name string, arr []interface{}) *schema.Struct {
	for _, item := range arr {
		if m, ok := item.(map[string]interface{}); ok {
			return buildStruct(name, m)
		}
		if _, ok := item.([]interface{}); ok {
			return buildStruct(name, map[string]interface{}{})
		}
		if item != nil {
			return nil
		}
	}
	return nil
}

func toPascalCase(s string) string {
	parts := strings.Split(s, "_")
	for i, p := range parts {
		if len(p) > 0 {
			parts[i] = strings.ToUpper(p[:1]) + p[1:]
		}
	}
	return strings.Join(parts, "")
}
