package json

import (
	"encoding/json"
	"paste-forge/pkg/parser"
	"paste-forge/pkg/schema"
	"strings"
)

type JSONParser struct{}

func NewJSONParser() parser.Parser {
	return &JSONParser{}
}

func (p *JSONParser) Name() string {
	return "json"
}

func (p *JSONParser) CanParse(content string) bool {
	content = strings.TrimSpace(content)
	if !strings.HasPrefix(content, "{") && !strings.HasPrefix(content, "[") {
		return false
	}
	var js json.RawMessage
	return json.Unmarshal([]byte(content), &js) == nil
}

func (p *JSONParser) Parse(content string) (*schema.Struct, error) {
	var data interface{}
	err := json.Unmarshal([]byte(content), &data)
	if err != nil {
		return nil, err
	}

	result := &schema.Struct{
		Name:   "AutoGenerated",
		Fields: []schema.Field{},
	}

	// Handle Array root: user expects a struct for the items
	if arr, ok := data.([]interface{}); ok {
		if len(arr) > 0 {
			data = arr[0] // infer from first element
		} else {
			data = map[string]interface{}{} // empty
		}
	}

	if m, ok := data.(map[string]interface{}); ok {
		for k, v := range m {
			field := schema.Field{
				Name:         toPascalCase(k),
				OriginalName: k,
				Kind:         schema.KindAny,
			}
			switch v.(type) {
			case string:
				field.Kind = schema.KindString
			case float64:
				field.Kind = schema.KindFloat // JSON numbers are floats by default
			case bool:
				field.Kind = schema.KindBool
			case map[string]interface{}:
				field.Kind = schema.KindObject
			case []interface{}:
				field.Kind = schema.KindArray
			}
			result.Fields = append(result.Fields, field)
		}
	}

	return result, nil
}

func toPascalCase(s string) string {
	parts := strings.Split(s, "_")
	for i, p := range parts {
		if len(p) > 0 {
			parts[i] = strings.ToUpper(p[:1]) + p[1:]
		}
	}
	return strings.Join(parts, "")
}
